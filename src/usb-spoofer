#!/usr/bin/env bash
# This script was generated by bashly 1.3.2 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
usb_spoofer_usage() {
  printf "usb-spoofer - Creation of virtual USB devices on Raspberry Pi Hardware using ConfigFS.\n\n"

  printf "%s\n" "Usage:"
  printf "  usb-spoofer COMMAND\n"
  printf "  usb-spoofer [COMMAND] --help | -h\n"
  printf "  usb-spoofer --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Create a virtual USB gadget. \n" "create    "
  printf "  %s   Remove a gadget\n" "remove    "
  printf "  %s   Activate a configured gadget\n" "activate  "
  printf "  %s   Deactivate a configured USB gadget\n" "deactivate"
  printf "  %s   List configured USB gadgets\n" "list      "
  printf "  %s   Mount the backing store of the USB gadget, e.g., to transfer files.\n" "mount     "
  printf "  %s   Unmount the backing store of the USB gadget and delete the mount point\n" "umount    "
  printf "  %s   Test if Pi is configured correctly\n" "test      "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
usb_spoofer_create_usage() {
  if [[ -n $long_usage ]]; then
    printf "usb-spoofer create\n\n"
    printf "  Create a virtual USB gadget. \n  Support various options to customize the device meta data. For a list of\n  valid combinations for vendor ID, product ID, manufacturer string, and\n  product string see http://www.linux-usb.org/usb.ids.\n\n"
  else
    printf "usb-spoofer create - Create a virtual USB gadget. \n\n"
  fi
  printf "Alias: c\n"
  echo

  printf "%s\n" "Usage:"
  printf "  usb-spoofer create NAME [OPTIONS]\n"
  printf "  usb-spoofer create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--size, -s SIZE"
    printf "    Define the size of the backing store (must be supported by fallocate).\n"
    printf "    %s\n" "Default: 1G"
    echo

    # :flag.usage
    printf "  %s\n" "--file-system, -F FILE_SYSTEM"
    printf "    The filesystem to be used on the USB gadget\n"
    printf "    %s\n" "Allowed: fat32, ntfs, exfat"
    printf "    %s\n" "Default: fat32"
    echo

    # :flag.usage
    printf "  %s\n" "--vendor-id, -V VENDOR_ID"
    printf "    Vendor ID  [HEX] of the USB gadget.\n"
    printf "    %s\n" "Default: 0x0951"
    echo

    # :flag.usage
    printf "  %s\n" "--product-id, -P PRODUCT_ID"
    printf "    Product ID [HEX] of the USB gadget.\n"
    printf "    %s\n" "Default: 0x1666"
    echo

    # :flag.usage
    printf "  %s\n" "--manufacturer, -M MANUFACTURER"
    printf "    Manufacturer string of the USB gadget.\n"
    printf "    %s\n" "Default: Kingston"
    echo

    # :flag.usage
    printf "  %s\n" "--product PRODUCT"
    printf "    Product string of the USB gadget.\n"
    printf "    %s\n" "Default: Data Traveler"
    echo

    # :flag.usage
    printf "  %s\n" "--serial-number, -S SERIAL_NUMBER"
    printf "    Serial number [HEX] of the USB gadget.\n"
    printf "    %s\n" "Default: 0x1234"
    echo

    # :flag.usage
    printf "  %s\n" "--label, -L LABEL"
    printf "    Label for the partition of the USB gadget. \n    Note: Might be restricted through used filesystem.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the USB gadget. \n    This will also be the name of the created backing file, in case the\n    device needs storage. The backing file will reside below /root but can\n    be accessed with the mount command of this script.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  usb-spoofer create usb_1 --vendor-id=0x0951 --product-id=0x160b\n  --manufacturer=\"Kingston Technology\" --product=\"DataTraveler 2.0 (2GB)\"\n  --serial-number=5404A6C0AFF8F170B9600284 --size=2G --file-system=fat32\n"
    echo

  fi
}

# :command.usage
usb_spoofer_remove_usage() {
  printf "usb-spoofer remove - Remove a gadget\n\n"
  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  usb-spoofer remove NAME [OPTIONS]\n"
  printf "  usb-spoofer remove --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--keep-backing-store, -k"
    printf "    Toggle to keep the backing store file on the Pi\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the USB gadget\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  usb-spoofer remove usb_1\n"
    printf "  usb-spoofer remove usb_1 --keep-backing-store\n"
    echo

  fi
}

# :command.usage
usb_spoofer_activate_usage() {
  printf "usb-spoofer activate - Activate a configured gadget\n\n"
  printf "Alias: a\n"
  echo

  printf "%s\n" "Usage:"
  printf "  usb-spoofer activate NAME\n"
  printf "  usb-spoofer activate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the USB gadget\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  usb-spoofer activate usb_1\n"
    echo

  fi
}

# :command.usage
usb_spoofer_deactivate_usage() {
  printf "usb-spoofer deactivate - Deactivate a configured USB gadget\n\n"
  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  usb-spoofer deactivate NAME\n"
  printf "  usb-spoofer deactivate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the USB gadget\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  usb-spoofer deactivate usb_1\n"
    echo

  fi
}

# :command.usage
usb_spoofer_list_usage() {
  printf "usb-spoofer list - List configured USB gadgets\n\n"
  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  usb-spoofer list [OPTIONS]\n"
  printf "  usb-spoofer list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Make the output of the list command more verbose\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
usb_spoofer_mount_usage() {
  if [[ -n $long_usage ]]; then
    printf "usb-spoofer mount\n\n"
    printf "  Mount the backing store of the USB gadget, e.g., to transfer files.\n  The default mount path will be /mnt/<name of USB gadget>, e.g.,\n  /mnt/usb_1. The normal user has read and write access.\n\n"
  else
    printf "usb-spoofer mount - Mount the backing store of the USB gadget, e.g., to transfer files.\n\n"
  fi
  printf "Alias: m\n"
  echo

  printf "%s\n" "Usage:"
  printf "  usb-spoofer mount [NAME]\n"
  printf "  usb-spoofer mount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the USB gadget\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  usb-spoofer mount usb_1\n"
    echo

  fi
}

# :command.usage
usb_spoofer_umount_usage() {
  printf "usb-spoofer umount - Unmount the backing store of the USB gadget and delete the mount point\n\n"
  printf "Alias: u\n"
  echo

  printf "%s\n" "Usage:"
  printf "  usb-spoofer umount [NAME]\n"
  printf "  usb-spoofer umount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the USB gadget\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  usb-spoofer umount usb_1\n"
    echo

  fi
}

# :command.usage
usb_spoofer_test_usage() {
  printf "usb-spoofer test - Test if Pi is configured correctly\n\n"

  printf "%s\n" "Usage:"
  printf "  usb-spoofer test\n"
  printf "  usb-spoofer test --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/filters.sh
filter_is_root() {
    if [ "$EUID" -ne 0 ]; then
        red "Please run this script as root"
    fi
}

# src/lib/gadget_present.sh
gadget_present(){
    if test -e /sys/kernel/config/usb_gadget/$1; then
        return 0
    else
        return 1
    fi
}

list_gadgets(){
    find /sys/kernel/config/usb_gadget -maxdepth 1 -mindepth 1 -type d
}

# src/lib/send_completions.sh
send_completions() {
  echo $'# usb-spoofer completion                                   -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_usb-spoofer_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $''
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_usb-spoofer_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'create\'*\'--file-system\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "fat32 ntfs exfat")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'c\'*\'--file-system\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "fat32 ntfs exfat")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'deactivate\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'create\'*\'-F\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "fat32 ntfs exfat")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'activate\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'create\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--file-system --help --label --manufacturer --product --product-id --serial-number --size --vendor-id -F -L -M -P -S -V -h -s")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'remove\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help --keep-backing-store -h -k")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'umount\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'mount\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'test\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'c\'*\'-F\')'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "fat32 ntfs exfat")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'list\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help --verbose -h -v")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'u\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'m\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'l\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help --verbose -h -v")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'d\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'a\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'r\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help --keep-backing-store -h -k")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'c\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--file-system --help --label --manufacturer --product --product-id --serial-number --size --vendor-id -F -L -M -P -S -V -h -s")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_usb-spoofer_completions_filter "--help --version -h -v a activate c create d deactivate l list m mount r remove test u umount")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'  complete -F _usb-spoofer_completions usb-spoofer'
  echo $''
  echo $'# ex: filetype=sh'
}

# :command.command_functions
# :command.function
usb_spoofer_create_command() {

  # src/create_command.sh
  create_backing_store() {
    fallocate -l ${args[--size]} "$HOME/${args[name]}"
    chmod og-rwx "$HOME/${args[name]}"
    # make the file immutable (might not be desirable)
    # chattr +i "$backing_store"
    loop_path=$(losetup --show -fP "$HOME/${args[name]}")
    echo ',,c,*' | sfdisk "$loop_path"

    case ${args[--file-system]} in
      "fat32")
        if [[ -n "${args[--label]}" ]]; then
            mkfs.vfat -F 32 -n "${args[--label]}" "${loop_path}p1"
        else
            mkfs.vfat -F 32 "${loop_path}p1"
        fi
        ;;
      "ntfs")
        if [[ -n "${args[--label]}" ]]; then
            mkfs.ntfs -L "${args[--label]}" "${loop_path}p1"
        else
            mkfs.ntfs "${loop_path}p1"
        fi
        ;;
      "exfat")
        if [[ -n "${args[--label]}" ]]; then
            mkfs.exfat -L "${args[--label]}" "${loop_path}p1"
        else
            mkfs.exfat "${loop_path}p1"
        fi
        ;;
    esac
    losetup -d "$loop_path"
  }

  mount_backing_store(){
      loop_path=$(losetup --show -fP $HOME/${args[name]})
      mkdir -p "/mnt/${args[name]}"
      mount "${loop_path}p1" "/mnt/${args[name]}"
  }

  umount_backing_store(){
      umount "/mnt/${args[name]}"
      losetup -d "$loop_path"
  }

  configure_device(){
    mkdir -p "/sys/kernel/config/usb_gadget/${args[name]}"
    cd "/sys/kernel/config/usb_gadget/${args[name]}" || exit 1
    echo ${args[--vendor-id]} > idVendor
    echo ${args[--product-id]} > idProduct
    echo 0x0100 > bcdDevice
    echo 0x0200 > bcdUSB
    echo 0xEF > bDeviceClass
    echo 0x02 > bDeviceSubClass
    echo 0x01 > bDeviceProtocol
    mkdir -p strings/0x409
    echo ${args[--serial-number]} > strings/0x409/serialnumber
    echo ${args[--manufacturer]} > strings/0x409/manufacturer
    echo ${args[--product]} > strings/0x409/product
    # init device config
    mkdir -p configs/c.1/strings/0x409
    echo "Config 1: Mass Storage" > configs/c.1/strings/0x409/configuration
    echo 250 > configs/c.1/MaxPower
    # Windows specific stuff
    echo "MSFT100" > os_desc/qw_sign
    echo 0xcd > os_desc/b_vendor_code # some use 0xcd
    echo 1 > os_desc/use
    # configure mass storage gadget see (https://www.kernel.org/doc/html/latest/admin-guide/abi-testing.html#abi-config-usb-gadget-gadget-functions-mass-storage-name-lun-name)
    mkdir -p functions/mass_storage.usb0
    echo 1 > functions/mass_storage.usb0/stall
    echo 0 > functions/mass_storage.usb0/lun.0/cdrom
    echo 0 > functions/mass_storage.usb0/lun.0/ro
    echo 0 > functions/mass_storage.usb0/lun.0/nofua
    echo 1 > functions/mass_storage.usb0/lun.0/removable
    echo ${args[--manufacturer]} > functions/mass_storage.usb0/lun.0/inquiry_string
    echo "$HOME/${args[name]}" > functions/mass_storage.usb0/lun.0/file
    ln -s functions/mass_storage.usb0 configs/c.1/
    udevadm settle -t 5 || :
  }

  if test -f $HOME/${args[name]}; then
    red "$HOME/${args[name]} already exists"
    red "No backing store will be created, but the existing one reused."
  else
    create_backing_store
  fi

  configure_device
  echo "${args[name]} successfully created"

}

# :command.function
usb_spoofer_remove_command() {

  # src/remove_command.sh
  cd "/sys/kernel/config/usb_gadget/${args[name]}"
  # start cleaning up
  rm configs/c.1/mass_storage.usb0
  # rm configs/c.1/MaxPower # this fails
  rmdir configs/c.1/strings/0x409
  rmdir configs/c.1
  # remove functions
  rmdir functions/mass_storage.usb0
  # remove strings
  rmdir strings/0x409
  cd $HOME
  rmdir "/sys/kernel/config/usb_gadget/${args[name]}"

  if [[ ${args[--keep-backing-store]:=0} == 0 ]] ; then
      rm "$HOME/${args[name]}"
  fi

}

# :command.function
usb_spoofer_activate_command() {

  # src/activate_command.sh
  if gadget_present ${args[name]}; then
      ls /sys/class/udc/ > "/sys/kernel/config/usb_gadget/${args[name]}/UDC"
  else
      red_bold "Gadget ${args[name]} was not configured"
  fi

}

# :command.function
usb_spoofer_deactivate_command() {

  # src/deactivate_command.sh
  if gadget_present ${args[name]}; then
      echo "" > "/sys/kernel/config/usb_gadget/${args[name]}/UDC"
  else
      red_bold "Gadget ${args[name]} is not configured"
  fi

}

# :command.function
usb_spoofer_list_command() {

  # src/list_command.sh
  mapfile -d $'\0' gadgets < <(find /sys/kernel/config/usb_gadget -maxdepth 1 -mindepth 1 -type d -print0)
  names=()
  vendor_ids=()
  manufacturers=()
  product_ids=()
  products=()
  serial_numbers=()
  file_systems=()

  for gadget in "${gadgets[@]}"
  do
      names+=("$(basename $gadget)")
      vendor_ids+=("$(cat $gadget/idVendor)")
      manufacturers+=("$(cat $gadget/strings/0x409/manufacturer)")
      product_ids+=("$(cat $gadget/idProduct)")
      products+=("$(cat $gadget/strings/0x409/product)")
      serial_numbers+=("$(cat $gadget/strings/0x409/serialnumber)")
  done

  # print table with info
  printf "%-15s | %-6s | %-15s | %-6s | %-15s | %-15s\n" "Name" "VID" "Manufacturer" "PID" "Product String" "Serial Number"
  printf '%s\n' "----------------|--------|-----------------|--------|-----------------|-----------------"

  # Print rows
  for ((i=0; i<${#gadgets[@]}; i++)); do
      printf "%-15s | %-6s | %-15s | %-6s | %-15s | %-15s\n" "${names[i]}"  "${vendor_ids[i]}" "${manufacturers[i]}" "${product_ids[i]}" "${products[i]}" "${serial_numbers[i]}"
      printf '%s\n' "----------------|--------|-----------------|--------|-----------------|-----------------"
  done
}

# :command.function
usb_spoofer_mount_command() {

  # src/mount_command.sh
  loop_path=$(losetup --show -fP $HOME/${args[name]})
  mkdir -p "/mnt/${args[name]}"
  mount -o uid=1000,gid=1000,umask=0022,rw "${loop_path}p1" "/mnt/${args[name]}"

}

# :command.function
usb_spoofer_umount_command() {

  # src/umount_command.sh
  loop_path=$(losetup --show -fP "$HOME/${args[name]}")
  umount "/mnt/${args[name]}"
  rmdir "/mnt/${args[name]}"
  losetup -d "$loop_path"

}

# :command.function
usb_spoofer_test_command() {

  # src/test_command.sh
    if ! grep -q dtoverlay=dwc2 /boot/firmware/config.txt; then
      echo -e "Please add the line 'dtoverlay=dwc2' below the [all] entry"
    fi

    if grep -q "^[[:space:]]*#.*otg_mode=1" /boot/firmware/config.txt; then
      :
    elif grep -q "^[[:space:]]*otg_mode=1" /boot/firmware/config.txt; then
      echo "Please disable otg_mode in /boot/firmware/config.txt"
    else
      :
    fi

    if ! grep -q libcomposite /etc/modules; then
      echo -e "Add the line 'libcomposite' to /etc/modules"
    fi

    if ! grep -q modules-load=dwc2 /boot/firmware/cmdline.txt; then
    # add modules-load=dwc2 as the only parameter (if already exists)
      echo "Please add 'modules-load=dwc2' parameter behind 'rootwait' in /boot/firmware/cmdline.txt"
    fi
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        usb_spoofer_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create | c)
      action="create"
      shift
      usb_spoofer_create_parse_requirements "$@"
      shift $#
      ;;

    remove | r)
      action="remove"
      shift
      usb_spoofer_remove_parse_requirements "$@"
      shift $#
      ;;

    activate | a)
      action="activate"
      shift
      usb_spoofer_activate_parse_requirements "$@"
      shift $#
      ;;

    deactivate | d)
      action="deactivate"
      shift
      usb_spoofer_deactivate_parse_requirements "$@"
      shift $#
      ;;

    list | l)
      action="list"
      shift
      usb_spoofer_list_parse_requirements "$@"
      shift $#
      ;;

    mount | m)
      action="mount"
      shift
      usb_spoofer_mount_parse_requirements "$@"
      shift $#
      ;;

    umount | u)
      action="umount"
      shift
      usb_spoofer_umount_parse_requirements "$@"
      shift $#
      ;;

    test)
      action="test"
      shift
      usb_spoofer_test_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      usb_spoofer_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
usb_spoofer_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        usb_spoofer_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v fallocate >/dev/null 2>&1; then
    printf "missing dependency: fallocate\n" >&2
    missing_deps=1
  else
    deps['fallocate']="$(command -v fallocate | head -n1)"
  fi

  # :dependency.filter
  if ! command -v sfdisk >/dev/null 2>&1; then
    printf "missing dependency: sfdisk\n" >&2
    missing_deps=1
  else
    deps['sfdisk']="$(command -v sfdisk | head -n1)"
  fi

  # :dependency.filter
  if ! command -v mkfs.vfat mkfs.ntfs mkfs.exfat >/dev/null 2>&1; then
    printf "missing dependency: file_system (mkfs.vfat/mkfs.ntfs/mkfs.exfat)\n" >&2
    missing_deps=1
  else
    deps['file_system']="$(command -v mkfs.vfat mkfs.ntfs mkfs.exfat | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --size | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--size']="$2"
          shift
          shift
        else
          printf "%s\n" "--size requires an argument: --size, -s SIZE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --file-system | -F)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--file-system']="$2"
          shift
          shift
        else
          printf "%s\n" "--file-system requires an argument: --file-system, -F FILE_SYSTEM" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --vendor-id | -V)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--vendor-id']="$2"
          shift
          shift
        else
          printf "%s\n" "--vendor-id requires an argument: --vendor-id, -V VENDOR_ID" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --product-id | -P)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--product-id']="$2"
          shift
          shift
        else
          printf "%s\n" "--product-id requires an argument: --product-id, -P PRODUCT_ID" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --manufacturer | -M)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--manufacturer']="$2"
          shift
          shift
        else
          printf "%s\n" "--manufacturer requires an argument: --manufacturer, -M MANUFACTURER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --product)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--product']="$2"
          shift
          shift
        else
          printf "%s\n" "--product requires an argument: --product PRODUCT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --serial-number | -S)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--serial-number']="$2"
          shift
          shift
        else
          printf "%s\n" "--serial-number requires an argument: --serial-number, -S SERIAL_NUMBER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --label | -L)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--label']="$2"
          shift
          shift
        else
          printf "%s\n" "--label requires an argument: --label, -L LABEL" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: usb-spoofer create NAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--size']:-} ]] || args['--size']="1G"
  [[ -n ${args['--file-system']:-} ]] || args['--file-system']="fat32"
  [[ -n ${args['--vendor-id']:-} ]] || args['--vendor-id']="0x0951"
  [[ -n ${args['--product-id']:-} ]] || args['--product-id']="0x1666"
  [[ -n ${args['--manufacturer']:-} ]] || args['--manufacturer']="Kingston"
  [[ -n ${args['--product']:-} ]] || args['--product']="Data Traveler"
  [[ -n ${args['--serial-number']:-} ]] || args['--serial-number']="0x1234"

  # :command.whitelist_filter
  if [[ ${args['--file-system']:-} ]] && [[ ! ${args['--file-system']:-} =~ ^(fat32|ntfs|exfat)$ ]]; then
    printf "%s\n" "--file-system must be one of: fat32, ntfs, exfat" >&2
    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
usb_spoofer_remove_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        usb_spoofer_remove_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="remove"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --keep-backing-store | -k)

        # :flag.case_no_arg
        args['--keep-backing-store']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: usb-spoofer remove NAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
usb_spoofer_activate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        usb_spoofer_activate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="activate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: usb-spoofer activate NAME\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
usb_spoofer_deactivate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        usb_spoofer_deactivate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="deactivate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: usb-spoofer deactivate NAME\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_is_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
usb_spoofer_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        usb_spoofer_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
usb_spoofer_mount_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        usb_spoofer_mount_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="mount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_is_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
usb_spoofer_umount_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        usb_spoofer_umount_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="umount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_is_root)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
usb_spoofer_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        usb_spoofer_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.1"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "create") usb_spoofer_create_command ;;
    "remove") usb_spoofer_remove_command ;;
    "activate") usb_spoofer_activate_command ;;
    "deactivate") usb_spoofer_deactivate_command ;;
    "list") usb_spoofer_list_command ;;
    "mount") usb_spoofer_mount_command ;;
    "umount") usb_spoofer_umount_command ;;
    "test") usb_spoofer_test_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
